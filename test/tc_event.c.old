#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>

#include "cmocka.h"

#include "lora_event.h"
#include "lora_system.h"

#include <string.h>
#include <stdlib.h>
#include <time.h>

#include "mock_system_time.h"

/* helpers */

static void eventHandler(struct lora_mac *receiver, uint32_t error)
{    
    check_expected_ptr(receiver);
    check_expected(error);
}

/* setups */

static int setup_event(void **user)
{
    static struct lora_event state;
    LDL_Event_init(&state, (struct lora_mac *)&state, NULL);
    *user = (void *)&state;                
    srand(time(0));
    system_time = rand();
    
    return 0;
}

/* expectations */

/*## init */

static void init_shall_init(void **user)
{
    assert_int_equal(0, setup_event(user));    
}

/*## onTimeout */

static void onTimeout_shall_register_immediate_timeout(void **user)
{    
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 0;
    
    assert_non_null( LDL_Event_onTimeout(self, timeout, eventHandler) );    
}

static void onTimeout_shall_register_future_timeout(void **user)
{    
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    assert_non_null( LDL_Event_onTimeout(self, timeout, eventHandler) );    
}

static void onTimeout_shall_not_register_if_resource_not_available(void **user)
{    
    struct lora_event *self = (struct lora_event *)(*user);    
    size_t i;
    
    uint32_t timeout = 0U;
    
    for(i=0U; i < EVENT_NUM_TIMERS; i++){
        
        assert_non_null( LDL_Event_onTimeout(self, timeout, eventHandler) );
    }
    
    assert_null( LDL_Event_onTimeout(self, timeout, eventHandler) );    
}

static void onTimeout_shall_register_at_maximum_interval(void **user)
{    
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = INT32_MAX;
    
    assert_non_null( LDL_Event_onTimeout(self, timeout, eventHandler) );    
}

static void onTimeout_shall_not_register_beyond_maximum_interval(void **user)
{    
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = INT32_MAX + 1U;
    
    assert_null( LDL_Event_onTimeout(self, timeout, eventHandler) );
}

/*## tick */

static void tick_shall_handle_immediate_timeout_now(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 0U;
    
    expect_value(eventHandler, receiver, (struct lora_mac *)self);
    expect_value(eventHandler, error, 0U);
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    LDL_Event_tick(self);    
}

static void tick_shall_handle_immediate_timeout_in_future(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 0U;
    
    expect_value(eventHandler, receiver, (struct lora_mac *)self);
    expect_value(eventHandler, error, 1U);
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    system_time++;
    
    LDL_Event_tick(self);    
}

static void tick_shall_not_handle_future_timeout_now(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    LDL_Event_tick(self);    
}

static void tick_shall_handle_future_timeout_at_timeout(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    expect_value(eventHandler, receiver, (struct lora_mac *)self);
    expect_value(eventHandler, error, 0U);
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    system_time++;
    
    LDL_Event_tick(self);    
}

static void tick_shall_handle_future_timeout_in_future(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    expect_value(eventHandler, receiver, (struct lora_mac *)self);
    expect_value(eventHandler, error, 1U);
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    system_time++;
    system_time++;
    
    LDL_Event_tick(self);    
}

static void tick_shall_handle_pending_input(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    
    expect_value(eventHandler, receiver, (struct lora_mac *)self);
    expect_value(eventHandler, error, 1U);
    
    LDL_Event_onInput(self, EVENT_TX_COMPLETE, eventHandler);
    
    LDL_Event_receive(self, EVENT_TX_COMPLETE, system_time);
    
    system_time++;
    
    LDL_Event_tick(self);    
}

/*## intervalUntilNext */

static void intervalUntilNext_shall_return_interval_for_immediate_timeout_now(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 0U;
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    assert_int_equal(0, LDL_Event_intervalUntilNext(self));
}

static void intervalUntilNext_shall_return_interval_for_immediate_timeout_in_future(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 0U;
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    system_time++;
    
    assert_int_equal(0, LDL_Event_intervalUntilNext(self));
}

static void intervalUntilNext_shall_return_interval_for_future_timeout_now(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    assert_int_equal(1U, LDL_Event_intervalUntilNext(self));
}

static void intervalUntilNext_shall_return_interval_for_future_timeout_at_timeout(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    system_time++;
    
    assert_int_equal(0U, LDL_Event_intervalUntilNext(self));
}

static void intervalUntilNext_shall_return_interval_for_pending_input(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    LDL_Event_onInput(self, EVENT_TX_COMPLETE, eventHandler);
    
    system_time++;
    
    assert_int_equal(UINT32_MAX, LDL_Event_intervalUntilNext(self));
    
    LDL_Event_receive(self, EVENT_TX_COMPLETE, system_time);
    
    assert_int_equal(0U, LDL_Event_intervalUntilNext(self));
    
    system_time++;
    
    assert_int_equal(0U, LDL_Event_intervalUntilNext(self));    
}

static void intervalUntilNext_shall_return_interval_for_future_timeout_in_future(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = 1U;
    
    LDL_Event_onTimeout(self, timeout, eventHandler);
    
    system_time++;
    system_time++;
    
    assert_int_equal(0U, LDL_Event_intervalUntilNext(self));
}

/*## cancel */

static void cancel_shall_remove_timeout_handler(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    uint32_t timeout = system_time;
    
    void *ptr = LDL_Event_onTimeout(self, timeout, eventHandler);
    
    assert_non_null( ptr );
    
    LDL_Event_cancel(self, &ptr);
    
    assert_null( ptr );
}

static void cancel_shall_remove_input_handler(void **user)
{
    struct lora_event *self = (struct lora_event *)(*user);    
    
    void *ptr = LDL_Event_onInput(self, EVENT_RX_READY, eventHandler);    
    
    assert_non_null( ptr );
    
    LDL_Event_cancel(self, &ptr);    
    
    assert_null( ptr );
}

/*## onInput */

static void onInput_shall_register(void **user)
{    
    struct lora_event *self = (struct lora_event *)(*user);    
    
    assert_non_null( LDL_Event_onInput(self, EVENT_TX_COMPLETE, eventHandler) );
}

/* runner */

int main(void)
{
    const struct CMUnitTest tests[] = {
        
        /* #init */
        cmocka_unit_test(
            init_shall_init
        ),
        
        /* #onTimeout */
        cmocka_unit_test_setup(
            onTimeout_shall_register_immediate_timeout, 
            setup_event
        ),
        cmocka_unit_test_setup(
            onTimeout_shall_register_future_timeout,
            setup_event
        ),
        cmocka_unit_test_setup(
            onTimeout_shall_not_register_if_resource_not_available,
            setup_event
        ),
        cmocka_unit_test_setup(
            onTimeout_shall_register_at_maximum_interval,
            setup_event
        ),
        cmocka_unit_test_setup(
            onTimeout_shall_not_register_beyond_maximum_interval,
            setup_event
        ),
        
        /* #tick */        
        cmocka_unit_test_setup(
            tick_shall_handle_immediate_timeout_now,
            setup_event
        ),
        cmocka_unit_test_setup(
            tick_shall_handle_immediate_timeout_in_future,
            setup_event
        ),
        cmocka_unit_test_setup(
            tick_shall_not_handle_future_timeout_now,
            setup_event
        ),
        cmocka_unit_test_setup(
            tick_shall_handle_future_timeout_at_timeout,
            setup_event
        ),
        cmocka_unit_test_setup(
            tick_shall_handle_future_timeout_in_future,
            setup_event
        ),
        cmocka_unit_test_setup(
            tick_shall_handle_pending_input,
            setup_event
        ),
        
        /* #interval */        
        cmocka_unit_test_setup(
            intervalUntilNext_shall_return_interval_for_immediate_timeout_now,
            setup_event
        ),
        cmocka_unit_test_setup(
            intervalUntilNext_shall_return_interval_for_immediate_timeout_in_future,
            setup_event
        ),
        cmocka_unit_test_setup(
            intervalUntilNext_shall_return_interval_for_future_timeout_now,
            setup_event
        ),
        cmocka_unit_test_setup(
            intervalUntilNext_shall_return_interval_for_future_timeout_at_timeout,
            setup_event
        ),
        cmocka_unit_test_setup(
            intervalUntilNext_shall_return_interval_for_future_timeout_in_future,
            setup_event
        ),
        cmocka_unit_test_setup(
            intervalUntilNext_shall_return_interval_for_pending_input,
            setup_event
        ),
        
        /* #onInput */
        cmocka_unit_test_setup(
            onInput_shall_register,
            setup_event
        ),
        
        /* #cancel */
        cmocka_unit_test_setup(
            cancel_shall_remove_timeout_handler,
            setup_event
        ),
        cmocka_unit_test_setup(
            cancel_shall_remove_input_handler,
            setup_event
        )        
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
